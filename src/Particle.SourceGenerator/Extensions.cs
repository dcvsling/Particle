// Source Generator: reads user UpdateScalar(ref T v) and emits SoA layout + SIMD kernel + dispatcher
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Particle.SourceGenerator;

internal static class Extensions
{
    internal const string DEFAULT_NAMESPACE = $"{nameof(Particle)}.{nameof(SourceGenerator)}";
    public static Candidate? GetCandidate(GeneratorSyntaxContext ctx)
    {
        if (ctx.Node is not MethodDeclarationSyntax md) return null;
        SemanticModel model = ctx.SemanticModel;
        if (model.GetDeclaredSymbol(md) is not IMethodSymbol msym) return null;
        if (!msym.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == "Particle.SimdFromMethodAttribute")) return null;
        if (msym.Parameters.Length != 1) return null; IParameterSymbol p = msym.Parameters[0];
        if (p.RefKind != RefKind.Ref) return null;                 // must be ref
        if (p.Type is not INamedTypeSymbol pts) return null;     // e.g., Particle2D
        return new Candidate(msym.ContainingType, msym, pts);
    }

    public static void EmitLayoutAndKernels(Compilation comp, SourceProductionContext spc, INamedTypeSymbol particle, IEnumerable<Candidate> candidates)
    {
        List<ISymbol> floatMembers = particle.GetMembers().Where(m =>
                (m is IFieldSymbol fs && fs.DeclaredAccessibility == Accessibility.Public && fs.Type.SpecialType == SpecialType.System_Single) ||
                (m is IPropertySymbol ps && ps.DeclaredAccessibility == Accessibility.Public && ps.Type.SpecialType == SpecialType.System_Single)).ToList();
        if (floatMembers.Count == 0)
        {
            spc.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("SIMD030", "No slots", "Type '{0}' has no public float fields/properties", "SimdParticles", DiagnosticSeverity.Error, true), particle.Locations.FirstOrDefault(), particle.ToDisplayString()));
            return;
        }

        string? ns = particle.ContainingNamespace.IsGlobalNamespace ? DEFAULT_NAMESPACE : particle.ContainingNamespace.ToDisplayString();
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/> DO NOT EDIT");
        sb.AppendLine("using System; using System.Numerics; using System.Runtime.CompilerServices;");
        if (ns is not null) sb.AppendLine($"namespace {ns} {{");

        // Layout for T
        sb.AppendLine($"public partial struct {particle.Name} {{ public enum Slots {{");
        for (int i = 0; i < floatMembers.Count; i++) sb.AppendLine($"  {floatMembers[i].Name.ToUpperInvariant()} = {i},");
        sb.AppendLine("}} }");

        sb.AppendLine($"public static class SimdLayout<{particle.Name}> {{ public static int SlotCount=>{floatMembers.Count}; public static string[] SlotNames=>new string[]{{{string.Join(", ", floatMembers.Select(m => "\"" + m.Name.ToUpperInvariant() + "\""))}}};");
        sb.AppendLine($"  [MethodImpl(MethodImplOptions.AggressiveInlining)] public static void ReadAoSToSoA(ReadOnlySpan<{particle.Name}> src, float[][] bufs, int n){{ for(int i=0;i<n;i++){{ var t=src[i];");
        for (int s = 0; s < floatMembers.Count; s++) sb.AppendLine($"    bufs[{s}][i]=t.{floatMembers[s].Name};");
        sb.AppendLine("  }}}");
        sb.AppendLine($"  [MethodImpl(MethodImplOptions.AggressiveInlining)] public static void WriteSoAToAoS(float[][] bufs, Span<{particle.Name}> dst, int n){{ for(int i=0;i<n;i++){{ ref var t=ref dst[i];");
        for (int s = 0; s < floatMembers.Count; s++) sb.AppendLine($"    t.{floatMembers[s].Name}=bufs[{s}][i];");
        sb.AppendLine("  }}}");
        sb.AppendLine("}");

        foreach (Candidate c in candidates)
        {
            MethodDeclarationSyntax mdecl = (MethodDeclarationSyntax)c.Method.DeclaringSyntaxReferences.First().GetSyntax();
            SemanticModel model = comp.GetSemanticModel(mdecl.SyntaxTree);
            List<(int slot, ExpressionSyntax rhs)> assigns = new List<(int slot, ExpressionSyntax rhs)>();
            Dictionary<string, int> alias = new Dictionary<string, int>(StringComparer.Ordinal);

            foreach (StatementSyntax st in ((MethodDeclarationSyntax)mdecl).Body!.Statements)
            {
                if (st is LocalDeclarationStatementSyntax ld && ld.Declaration.Variables.Count == 1 && ld.Modifiers.Any(SyntaxKind.RefKeyword))
                {
                    VariableDeclaratorSyntax v = ld.Declaration.Variables[0]; string name = v.Identifier.Text;
                    if (v.Initializer?.Value is RefExpressionSyntax re && re.Expression is MemberAccessExpressionSyntax ma)
                    {
                        if (TryFieldSlot(model, ma, particle, floatMembers, out int sidx)) alias[name] = sidx;
                    }
                }
            }

            foreach (StatementSyntax st in ((MethodDeclarationSyntax)mdecl).Body!.Statements)
            {
                if (st is ExpressionStatementSyntax es && es.Expression is AssignmentExpressionSyntax ae)
                {
                    int? slot = null;
                    if (ae.Left is MemberAccessExpressionSyntax ma && TryFieldSlot(model, ma, particle, floatMembers, out int s1)) slot = s1;
                    else if (ae.Left is IdentifierNameSyntax id && alias.TryGetValue(id.Identifier.Text, out int s2)) slot = s2;
                    if (slot is null)
                    {
                        spc.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("SIMD031", "Invalid LHS", "Expected assignment to v.<field> or its ref alias", "SimdParticles", DiagnosticSeverity.Error, true), st.GetLocation()));
                        return;
                    }
                    assigns.Add((slot.Value, ae.Right));
                }
            }

            string[] pFields = c.EffectType.GetMembers().Where(m =>
                    (m is IFieldSymbol fs && fs.DeclaredAccessibility == Accessibility.Public && fs.Type.SpecialType == SpecialType.System_Single) ||
                    (m is IPropertySymbol ps && ps.DeclaredAccessibility == Accessibility.Public && ps.Type.SpecialType == SpecialType.System_Single)).Select(m => m.Name).ToArray();

            string kname = c.EffectType.Name + "_SimdKernel_" + particle.Name;
            sb.AppendLine($"public static class {kname} {{");
            sb.AppendLine($"  [MethodImpl(MethodImplOptions.AggressiveOptimization)] public static void Update(ParticlesSoA<{particle.Name}> ps, in {c.EffectType.ToDisplayString()} p) {{");
            sb.AppendLine("    int n=ps.Count, w=Vector<float>.Count, i=0; var B=ps.Buffers;");
            foreach (string? f in pFields) sb.AppendLine($"    var v_{f}=new Vector<float>(p.{f});");
            int[] used = assigns.Select(a => a.slot).Distinct().ToArray();
            sb.AppendLine("    for(; i<=n-w; i+=w){");
            foreach (int s in used) sb.AppendLine($"      var S{s} = new Vector<float>(B[{s}].AsSpan(i,w));");
            foreach ((int slot, ExpressionSyntax rhs) in assigns) { string codeV = LowerVector(model, rhs, particle, floatMembers, alias, pFields); sb.AppendLine($"      S{slot} = {codeV};"); }
            foreach (int s in used) sb.AppendLine($"      S{s}.CopyTo(B[{s}].AsSpan(i,w));");
            sb.AppendLine("    }");
            sb.AppendLine("    for(; i<n; i++){");
            foreach ((int slot, ExpressionSyntax rhs) in assigns) { string codeS = LowerScalar(model, rhs, particle, floatMembers, alias, pFields); sb.AppendLine($"      B[{slot}][i] = {codeS};"); }
            sb.AppendLine("    }");
            sb.AppendLine("  }");
            sb.AppendLine("}");

            string? effNs = c.EffectType.ContainingNamespace.IsGlobalNamespace ? null : c.EffectType.ContainingNamespace.ToDisplayString();
            string partNsPrefix = ns is null ? "" : ns + ".";
            StringBuilder effSb = new StringBuilder();
            if (effNs is not null) effSb.AppendLine($"namespace {effNs} {{");
            effSb.AppendLine("using System.Runtime.CompilerServices;");
            effSb.AppendLine($"public partial struct {c.EffectType.Name} {{");
            effSb.AppendLine($"  [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Update(ParticlesSoA<{partNsPrefix}{particle.Name}> ps) => {kname}.Update(ps, in this);");
            effSb.AppendLine("}");
            if (effNs is not null) effSb.AppendLine("}");
            spc.AddSource($"{c.EffectType.Name}.Dispatcher.g.cs", effSb.ToString());
        }

        if (ns is not null) sb.AppendLine("}");
        spc.AddSource($"{particle.Name}.SimdLayout.g.cs", sb.ToString());
    }

    public static bool TryFieldSlot(SemanticModel model, MemberAccessExpressionSyntax ma, INamedTypeSymbol particle, List<ISymbol> floatMembers, out int slot)
    {
        slot = -1;
        if (ma.Expression is IdentifierNameSyntax id && id.Identifier.Text == "v")
        {
            string name = ma.Name.Identifier.Text;
            for (int i = 0; i < floatMembers.Count; i++)
                if (string.Equals(floatMembers[i].Name, name, StringComparison.Ordinal)) { slot = i; return true; }
        }
        return false;
    }

    public static string LowerVector(SemanticModel model, ExpressionSyntax e, INamedTypeSymbol particle, List<ISymbol> floatMembers, Dictionary<string, int> alias, string[] effectFields)
    {
        return e switch
        {
            BinaryExpressionSyntax b => $"({LowerVector(model, b.Left, particle, floatMembers, alias, effectFields)} {Op(b)} {LowerVector(model, b.Right, particle, floatMembers, alias, effectFields)})",
            ParenthesizedExpressionSyntax p => $"({LowerVector(model, p.Expression, particle, floatMembers, alias, effectFields)})",
            MemberAccessExpressionSyntax ma when TryFieldSlot(model, ma, particle, floatMembers, out int s) => $"new Vector<float>(B[{s}].AsSpan(i,w))",
            IdentifierNameSyntax id when alias.TryGetValue(id.Identifier.Text, out int s2) => $"new Vector<float>(B[{s2}].AsSpan(i,w))",
            IdentifierNameSyntax id2 when effectFields.Contains(id2.Identifier.Text) => $"v_{id2.Identifier.Text}",
            LiteralExpressionSyntax lit => $"new Vector<float>({lit.Token.ValueText}f)",
            _ => "new Vector<float>(0f)",
        };
    }

    public static string LowerScalar(SemanticModel model, ExpressionSyntax e, INamedTypeSymbol particle, List<ISymbol> floatMembers, Dictionary<string, int> alias, string[] effectFields)
    {
        return e switch
        {
            BinaryExpressionSyntax b => $"({LowerScalar(model, b.Left, particle, floatMembers, alias, effectFields)} {Op(b)} {LowerScalar(model, b.Right, particle, floatMembers, alias, effectFields)})",
            ParenthesizedExpressionSyntax p => $"({LowerScalar(model, p.Expression, particle, floatMembers, alias, effectFields)})",
            MemberAccessExpressionSyntax ma when TryFieldSlot(model, ma, particle, floatMembers, out int s) => $"B[{s}][i]",
            IdentifierNameSyntax id when alias.TryGetValue(id.Identifier.Text, out int s2) => $"B[{s2}][i]",
            IdentifierNameSyntax id2 when effectFields.Contains(id2.Identifier.Text) => $"p.{id2.Identifier.Text}",
            LiteralExpressionSyntax lit => lit.Token.ValueText + "f",
            _ => "0f",
        };
    }

    public static string Op(BinaryExpressionSyntax b) => b.Kind() switch
    {
        SyntaxKind.AddExpression => "+",
        SyntaxKind.SubtractExpression => "-",
        SyntaxKind.MultiplyExpression => "*",
        SyntaxKind.DivideExpression => "/",
        _ => "+"
    };

}